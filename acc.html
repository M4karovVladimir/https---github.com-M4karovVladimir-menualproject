<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="/css/main.css">
    <title>Document</title>
    
</head>
<body>
    <header>
        <nav>
            <ul>
                <img src="/css/img/logo.png" height="75px"/>

            <a href="index.html" class="text">
                <li>Про Linux</li>
            </a>

            <a href="gallery.html" class="text">
                <li>Основные понятия</li>
            </a>

            <a href="aboutus.html" class="text">
                <li>О нас</li>
            </a>
            <a href="contacts.html" class="text">
                <li>Дистрибутивы</li>
        </a>
                </ul>
                </nav>
                <h1 style="color: white;">Потоки</h1>

                <p>Определение</p>
                <p>Поток выполнения (англ. thread — нить) — наименьшая единица обработки, исполнение которой может быть назначено ядром операционной системы. Несколько потоков выполнения могут существовать в рамках одного и того же процесса и совместно использовать ресурсы, такие как память, тогда как процессы не разделяют этих ресурсов. В частности, потоки выполнения разделяют инструкции процесса (его код) и его контекст (значения переменных, которые они имеют в любой момент времени).</p>
                <p>Преимущества потоков:</p>
                <p>* Потоки довольно просто обмениваются данными по сравнению с процессами.</p>
                <p>* Создавать потоки для ОС проще и быстрее (иногда на порядок), чем создавать процессы.</p>
                <p>Недостатки потоков:</p>
                <p>* При программировании приложения с множественными потоками необходимо постоянно думать о потокобезопасности (т. н. thread safety). Приложения, выполняющиеся через множество процессов, не имеют таких требований.</p>
                <p>* Один бажный поток может повредить остальные, так как потоки делят общее адресное пространство. Процессы более изолированы друг от друга.</p>
                <p>* Потоки конкурируют друг с другом в адресном пространстве. Стек и thread-local storage, занимая часть виртуального адресного пространства процесса, тем самым делают его недоступным для других потоков. Для встраиваемых (embedded) систем в условиях ограниченности ресурсов такое ограничение может иметь существенное значение.</p>

                <p>POSIX Threads:</p>
                <p>Это стандарт POSIX-реализации потоков. Стандарт POSIX.1c, Threads extensions (IEEE Std 1003.1c-1995) определяет API для управления потоками, их синхронизации и планирования.

                    Реализации данного API существуют для большого числа UNIX-подобных ОС (GNU/Linux, Solaris, FreeBSD, OpenBSD, NetBSD, OS X), а также для Microsoft Windows и других ОС.
                    
                    Библиотеки, реализующие этот стандарт (и функции этого стандарта), обычно называются pthreads (функции имеют приставку «pthread_»).</p>
                <p>Реализации в Linux:</p>
                <p>Для Linux известны две реализации Pthreads API:

                    LinuxThreads — старая (появилась в 1996 году), оригинальная,
                    NPTL (Native POSIX Threads Library) — современная (появилась в ядрах 2.6 в 2003 году), более чётко следует стандарту, сегодня является частью libc.
                    Проверить, какая используется реализация, можно так:
                    
                    $ getconf GNU_LIBPTHREAD_VERSION
                    NPTL 2.23</p>
                <p>С точки зрения ядра Linux:</p>
                    <p>есть «runnable entities» — что-то, что можно запустить и выполнение чего можно планировать. В ядре это называется процессом.

                        Поток — особый тип процесса, который делит виртуальное адресное пространство и обработчики сигналов с другими процессами.
                        
                        Для ядра каждый процесс идентифицируется по PID. Для так называемых потоков можно использовать термин TID, но для ядра это одно и то же. Можно понимать это так:
                        
                        если процесс однопоточный, то PID будет равен TID этого единственного потока;
                        если в процессе работают несколько потоков, то у каждого потока свой TID, а PID идентифицирует группу потоков, которая разделяет адресное пространство, таблицу файловых дескрипторов...
                        Получается, что функции вида getpid, kill, ... на самом деле работают с идентификаторами групп потоков. Функция gettid, выдающая TID текущего потока, нестандартная, для неё нет glibc-обёртки. При желании эту информацию достать можно:
                    </p>
                     <p>#include unistd.h></p> 
                      <p>#include sys/syscall.h></p> 
                         
                       <p>#ifdef SYS_gettid</p>
                       <p>pid_t tid = syscall(SYS_gettid);</p>
                       <p>#else</p>
                       <p>#error "SYS_gettid unavailable on this system"</p>
                       <p>#endif</p>
                       <p>В среде Microsoft Windows концепция иная, там процесс — это контейнер для потоков. Процесс-контейнер содержит как минимум один поток. Если потоков в процессе несколько, приложение (процесс) становится многопоточным.</p>

                        <p>Вывод списка потоков:</p>
                        <p>Утилита ps по умолчанию для многопоточного процесса выводит одну строку. Чтобы выводить несколько, можно выполнить

                            $ ps -L
                            Утилита htop выводит список потоков. Чтобы выводить только процессы, есть опция «Hide userland threads».</p>

                        <p>Потоки и nice:</p>
                        <p>Напомним, что число nice задаёт приоритет выполнения процесса: от −20 (наивысший приоритет) до +19 (низший приоритет).

                            Хоть это и противоречит стандарту, но потоки не разделяют nice-значение.
                            
                            Если вы применяете утилиту renice, то нужно применить её к каждому потоку.</p>

                        <p>Потоки и сигналы:</p>
                        <p>Сигналы были придуманы задолго до появления Pthreads.

                            Комбинирование потоков и сигналов — сложное дело, стоит его избегать почти всегда.</p>

                        <p>Потоки и fork — exec</p>
                        <p>Если поток вызывает exec(), остальные потоки тут же уничтожаются, никакие деструкторы и функции очистки не вызываются.

                            Если поток вызывает fork(), то только этот поток будет продолжать работать в новом дочернем процессе.</p>
                            <img src="/css/img/potok.png"/>
                </header> 
</body>
</html>